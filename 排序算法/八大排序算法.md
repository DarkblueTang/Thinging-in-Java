### 1. 插入排序

![原理图](../imgs/insert-sort.gif)

插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

**算法步骤：**

1）将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。

2）从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

**代码实现：** 

```java
    public static void insert_sort(int[] a) {
        for (int i = 0; i < a.length; i++) {
            int temp = a[i];
            for (int j = i; j >= 1; j--) {
                if (temp < a[j - 1]) {
                    a[j] = a[j - 1];
                    a[j - 1] = temp;
                    continue;
                }
            }
        }
    }
```

### 2. 希尔排序

希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。本文会以图解的方式详细介绍希尔排序的基本思想及其代码实现。 

**希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。** 

简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。

　　我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2...1}，称为**增量序列**。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。

![img](../imgs/11.png)

在希尔排序的理解时，我们倾向于对于每一个分组，逐组进行处理，但在代码实现中，我们可以不用这么按部就班地处理完一组再调转回来处理下一组（这样还得加个for循环去处理分组）比如[5,4,3,2,1,0] ，首次增量设gap=length/2=3,则为3组[5,2][4,1] [3,0]，实现时不用循环按组处理，我们可以从第gap个元素开始，逐个跨组处理。同时，在插入数据时，可以采用元素交换法寻找最终位置，也可以采用数组元素移动法寻觅。希尔排序的代码比较简单，如下： 

```java
	private static void shell_sort(int[] a) {
        for (int gap = a.length; gap > 0; gap /= 2) {
            for (int i = gap; i < a.length; i++) {
                int temp = a[i], k = i;
                for (int j = i; j >= gap; j -= gap) {
                    if (a[j - gap] > temp) {
                        a[j] = a[j - gap];
                        k = j - gap;
                    }
                }
                a[k] = temp;
            }
        }
    }
```

### 3.选择排序

![img](../imgs/selection_sort_animation.gif)

选择排序示意图

**选择排序**(Selection sort)也是一种简单直观的排序算法。

**算法步骤**：

1）首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置

2）再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。

3）重复第二步，直到所有元素均排序完毕。

 **代码实现：**

```java

    private static void select_sort(int[] a) {
        for (int i = 0; i < a.length - 1; i++) {
            int temp = a[i], k = i;
            for (int j = i; j < a.length; j++) {
                if(temp > a[j]){
                    temp = a[j];
                    k = j;
                }
            }
            temp = a[k];
            a[k] = a[i];
            a[i] = temp;
        }
    }
```

### 4. 冒泡排序

![img](../imgs/bubble_sort_animation.gif)

冒泡排序示意图

 **冒泡排序**（**Bubble Sort**）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

**算法步骤**：

1）比较相邻的元素。如果第一个比第二个大，就交换他们两个。

2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。

3）针对所有的元素重复以上的步骤，除了最后一个。

4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

 **代码实现：**

```java
	private static void bubble_sort(int[] a) {
        for (int i = 0; i < a.length; i++) {
            for (int j = 0; j < a.length - i - 1; j++) {
                if (a[j] > a[j + 1]) {
                    int temp = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = temp;
                }
            }
        }
    }
```

### 5. 归并排序

![img](../imgs/merge_sort_animation2.gif)

归并排序示意图

**归并排序（Merge sort）**是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。

**算法步骤：**

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列

2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针达到序列尾

5. 将另一序列剩下的所有元素直接复制到合并序列尾

**代码实现：**

```java
    private static void merge_sort(int[] a, int start, int end) {
        if (start < end) {
            int mid = (start + end) / 2;
            merge_sort(a, start, mid);
            merge_sort(a, mid + 1, end);
            merge(a, start, end);
        }
    }

    private static void merge(int[] a, int start, int end) {
        for (int i = start, mid = (start + end) / 2, j = mid + 1; i <= mid && j <= end; ) {
            if (a[i] < a[j]) {
                i++;
            } else {
                int temp = a[j], k = j;
                while (k > i) {
                    a[k] = a[--k];
                }
                a[i] = temp;
                j++;
            }
        }
    }
```

### 6. 快速排序

![img](../imgs/Sorting_quicksort_anim.gif)

快速排序示意图

**快速排序**是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 *n* 个项目要**Ο**(*n* log *n*)次比较。在最坏状况下则需要**Ο**(*n*2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他**Ο**(*n* log *n*) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。

快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。

**算法步骤：**

1 从数列中挑出一个元素，称为 “基准”（pivot），

2 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为**分区（partition）**操作。

3 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

**代码实现：**

```java
    private static void quick_sort(int[] a, int start, int end) {
        if(start >= end) return;
        int temp = a[start], low = start, height = end;
        while(low < height){
            while(low < height && temp <= a[height]) height--;
            a[low] = a[height];
            while(low < height && temp >= a[low])low++;
            a[height] = a[low];
        }
        a[low] = temp;
        quick_sort(a, start, low-1);
        quick_sort(a, low+1, end);
    }
```



